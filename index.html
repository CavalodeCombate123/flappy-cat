<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Gatinho Flappy - VersÃ£o Final Otimizada Mobile</title>
<link rel="manifest" href="manifest.json">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* ---------------------------- Estilos Gerais Otimizados ---------------------------- */
body {
    margin: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background: #f7f7f7;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
}

/* Container do Jogo: Usa unidades de viewport para ser totalmente responsivo */
#game-container {
    position: relative;
    /* ğŸ›‘ NOVO: Maximizamos o uso da tela no celular */
    width: 95vw; 
    height: 95vh; 
    /* Garante que o jogo nÃ£o fique muito grande em telas horizontais (PC/Tablets) */
    max-width: 480px; 
    max-height: 640px; 
    margin: auto;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    border-radius: 8px;
    align-self: center; 
}

/* Canvas do Jogo e Confetti */
canvas {
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 8px;
    /* Garante que o canvas nÃ£o tenha scroll ou zoom indesejado */
    touch-action: none;
}

/* Overlay Tela Inicial e Game Over: Usa flexbox para centralizar tudo */
.screen-overlay {
    position: absolute;
    top:0; left:0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85); 
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    border-radius: 8px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.4s;
    z-index: 10;
}

.screen-overlay.active {
    pointer-events: auto;
    opacity: 1;
}

.screen-overlay h1 {
    font-size: clamp(1.8rem,8vw,3rem); 
    color: #ffcc00;
    text-shadow: 2px 2px 4px #000;
    margin-bottom: 5px;
}

.screen-overlay p {
    font-size: clamp(1rem,4vw,1.2rem);
    margin: 5px 0 20px 0;
}

/* Estilo dos botÃµes de NÃ­vel */
#level-select-screen .level-list {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px; 
    max-width: 90%;
    margin-top: 20px;
}

#level-select-screen button,
.screen-overlay button {
    background: #ff99aa;
    color: #3d2b27;
    border: 3px solid #3d2b27;
    padding: 15px 15px;
    font-size: clamp(1rem,4vw,1.4rem);
    cursor: pointer;
    border-radius: 10px;
    transition: 0.2s;
    width: 90%; 
    max-width: 200px; 
    margin-top: 10px; 
}

#level-select-screen button:disabled {
    background: #555;
    color: #ccc;
    border-color: #333;
    cursor: not-allowed;
}


/* Placar */
#score-display {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-size: clamp(1.2rem,5vw,1.8rem); 
    font-weight: bold;
    color: #3d2b27;
    text-shadow: 2px 2px 0 white;
    z-index: 5;
    padding: 5px 10px;
    border-radius: 5px;
    background: rgba(255,255,255,0.7);
}

/* Mensagem de NÃ­vel ConcluÃ­do (usada como um container de vitÃ³ria agora) */
#level-completed-message {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95); 
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    z-index: 15;
    opacity: 0;
    transition: opacity 0.5s;
    pointer-events: none;
    border-radius: 8px;
    padding: 20px; 
    box-sizing: border-box;
}
#level-completed-message.active {
    opacity: 1;
    pointer-events: auto;
}

#victory-text {
    font-size: clamp(1.1rem, 4vw, 1.8rem); 
    font-weight: bold;
    color: #00ff7f; 
    text-shadow: 2px 2px 4px #000;
    margin-bottom: 10px;
    white-space: pre-wrap; 
    max-height: 60vh; 
    overflow-y: auto; 
    padding: 10px;
    line-height: 1.4;
}

/* Estilo para a imagem de vitÃ³ria */
#victory-cat {
    width: clamp(100px, 30vw, 150px);
    height: auto;
    margin-bottom: 20px;
    image-rendering: pixelated; 
    display: none; 
}

/* Estilo pixelado para o botÃ£o de selecionar nÃ­vel na tela de vitÃ³ria */
#level-completed-message button {
    background: #ffcc00; 
    color: #3d2b27;
    border: 5px solid #000000; 
    border-radius: 0; 
    padding: 18px 25px; 
    font-size: clamp(1.1rem,4.5vw,1.6rem); 
    font-weight: bold;
    text-transform: uppercase;
    box-shadow: 4px 4px 0px 0px rgba(0,0,0,0.75); 
    transition: background-color 0.1s ease, box-shadow 0.1s ease;
    margin-top: 20px; 
}

#level-completed-message button:hover {
    background-color: #ff9900; 
    box-shadow: 2px 2px 0px 0px rgba(0,0,0,0.75); 
    transform: translate(2px, 2px); 
}
</style>
</head>
<body>
<div id="game-container">
Â  Â  <canvas id="game" width="480" height="640"></canvas>
Â  Â  <canvas id="confetti" width="480" height="640"></canvas>

Â  Â  <div id="score-display">Pontos: 0</div>

Â  Â  <div id="start-screen" class="screen-overlay active">
Â  Â  Â  Â  <h1>Gatinho Flappy ğŸ¾</h1>
Â  Â  Â  Â  <p>Escolha o seu NÃ­vel de Desafio!</p>
Â  Â  Â  Â  <button onclick="showLevelSelect()">ComeÃ§ar</button>
Â  Â  </div>

Â  Â  <div id="level-select-screen" class="screen-overlay">
Â  Â  Â  Â  <h1>Escolha a Fase</h1>
Â  Â  Â  Â  <p>Complete a fase atual para desbloquear a prÃ³xima!</p>
Â  Â  Â  Â  <div class="level-list" id="level-list">
Â  Â  Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="game-over-screen" class="screen-overlay">
Â  Â  Â  Â  <h1>GAME OVER ğŸ˜¿</h1>
Â  Â  Â  Â  <p id="final-score">PontuaÃ§Ã£o Final: 0</p>
Â  Â  Â  Â  <button onclick="showLevelSelect()">Voltar para a SeleÃ§Ã£o</button>
Â  Â  </div>

Â  Â  <div id="level-completed-message">
Â  Â  Â  Â  <div id="victory-text"></div>
Â  Â  Â  Â  <img id="victory-cat" src="greg.png"> 
Â  Â  Â  Â  <button onclick="showLevelSelect()">Voltar para a SeleÃ§Ã£o de NÃ­veis</button>
Â  Â  </div>
</div>

<script>
/* ---------------------------- VariÃ¡veis do Canvas e Elementos ---------------------------- */
const gameContainer = document.getElementById('game-container');
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const confCanvas = document.getElementById('confetti');
const confCtx = confCanvas.getContext('2d');

const startScreen = document.getElementById('start-screen');
const levelSelectScreen = document.getElementById('level-select-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const scoreDisplay = document.getElementById('score-display');
const finalScoreText = document.getElementById('final-score');

// Elementos da Tela de VitÃ³ria
const levelCompletedScreen = document.getElementById('level-completed-message');
const victoryText = document.getElementById('victory-text');
const victoryCatImg = document.getElementById('victory-cat'); 
const levelListContainer = document.getElementById('level-list');


/* ---------------------------- ConfiguraÃ§Ãµes Globais e de Jogo ---------------------------- */
const pipeWidth = 70; 
const pipeInterval = 120; 
const initialDelay = 80; 
const pointsToCompleteLevel = 10;  

// â±ï¸ NOVO: CONFIGURAÃ‡Ã•ES DE TEMPO PARA LOOP FIXO
const FRAME_RATE = 60; // Queremos 60 atualizaÃ§Ãµes por segundo
const TIME_STEP = 1000 / FRAME_RATE; // DuraÃ§Ã£o de um frame em milissegundos (aprox. 16.67ms)

let lastTime = 0; // Armazena o tempo do Ãºltimo quadro
let accumulatedTime = 0; // Acumula o tempo que passou desde a Ãºltima atualizaÃ§Ã£o da lÃ³gica


let animationId = null;
let pipeFrame = 0; 
let score = 0;
let pipes = [];
let gameRunning = false;
let gameOver = false;
let currentLevel = 0; 

let gravity = 0;
let jumpForce = 0;
let pipeSpeed = 0;
let minGap = 0;
let maxGap = 0; 


/* ---------------------------- DIFICULDADE FIXA E MENSAGENS ---------------------------- */
const EASY_MODE_SETTINGS = { 
Â  Â  gravity: 0.3, 
Â  Â  jump: -7.0, 
Â  Â  speed: 2.25, 
Â  Â  gap: 200, 
Â  Â  maxGap: 280 
};

// MENSAGEM FINAL DE VITÃ“RIA
const FINAL_VICTORY_MESSAGE = `
ParabÃ©ns, vocÃª completou o jogo!
Esse jogo foi algo inesperado e que surgiu na minha cabeÃ§a do nada... E por isso foi algo que eu considerei muito importante, jÃ¡ que eu nunca tinha feito algo assim... Mas, aproveitei que estava estudando e tentei fazer... EntÃ£o espero que tenha gostado, mesmo que sÃ³ um pouco.

Layane, eu te desejo infinitas felicidades e um feliz aniversÃ¡rio
Desejo que todas as coisas boas desse mundo, venham em sua direÃ§Ã£o
Espero que vocÃª sempre seja essa pessoa incrivel maravilhosa e charmosa
VocÃª sempre foi e sempre vai ser uma pessoa muito importante na vida de todos nÃ³s
E eu nÃ£o poderia ser mais grato por ter conhecido alguÃ©m como vocÃª
Sua felicidade Ã© a alegria de todos, incluindo a minha
Meu maior desejo Ã© que vocÃª seja feliz em tudo o que vocÃª se proponha a fazer
Pois Ã© assim que eu sempre quis te ver.
`;

// ğŸ›‘ ALTERAÃ‡ÃƒO PRINCIPAL AQUI: Adicionamos 'bgSrc', 'pipeColor' e 'groundColor'
const LEVEL_SETTINGS = [
Â  Â  { 
        name: "Gatinhos", 
        message: "Uau, vocÃª Ã© boa nisso ein?", 
        bgSrc: 'gato.png',          // NOVO Fundo para NÃ­vel 1
        pipeColor: '#332dd6',          // Rosa Choque
        groundColor: '#F0E68C', 
        pipeCapColor: '#44877d', // ğŸ¨ NOVO: Cor de tampa para o NÃ­vel 1 (vermelho escuro)
        bgmSrc: 'sfx/bgm_nivel1.mp3',       // Amarelo Claro (Areia)
        ...EASY_MODE_SETTINGS 
    }, 
Â  Â  { 
        name: "Parque", 
        message: "Vai Corinthians... Quer dizer, VÃƒO GATINHOS!", 
        bgSrc: 'world.png',          // NOVO Fundo para NÃ­vel 2
        pipeColor: '#008000',          // Verde Floresta
        groundColor: '#3CB371',        // Verde MÃ©dio (Grama)
        pipeCapColor: '#556B2F', // ğŸ¨ NOVO: Verde Oliva escuro para combinar com o parque
        bgmSrc: 'sfx/bgm_nivel2.mp3',       // Verde Escuro
        ...EASY_MODE_SETTINGS 
    }, 
Â  Â  { 
        name: "Piscina", 
        message: "VocÃª tÃ¡ trapaceando...", 
        bgSrc: 'piscina.png',          // NOVO Fundo para NÃ­vel 3
        pipeColor: '#4682B4',          // Azul AÃ§o (Tubo de PVC)
        groundColor: '#1E90FF',   
        pipeCapColor: '#000080', // ğŸ¨ NOVO: Azul Marinho para contraste com a Ã¡gua
        bgmSrc: 'sfx/bgm_nivel3.mp3',      // Azul Forte (Ãgua)
        ...EASY_MODE_SETTINGS 
    }, 
Â  Â  { 
        name: "Caixa de Areia", 
        message: "Mas jÃ¡? TÃ¡ muito fÃ¡cil!", 
        bgSrc: 'deserto.png',       // NOVO Fundo para NÃ­vel 4
        pipeColor: '#964B00',          // Marrom (Madeira)
        groundColor: '#FFDAB9',                  
        pipeCapColor: '#A0522D', // ğŸ¨ NOVO: Marrom mais escuro para areia
        bgmSrc: 'sfx/bgm_nivel4.mp3',       // PÃªssego (Areia Clara)
        ...EASY_MODE_SETTINGS 
    }, 
Â  Â  { 
        name: "Greg", 
        message: "VocÃª Ã© incrÃ­vel! Veja a mensagem final.", 
        bgSrc: 'aniversario.png',         // NOVO Fundo para NÃ­vel 5
        pipeColor: '#FFD700',          // Dourado (Festa)
        groundColor: '#800080',
        pipeCapColor: '#000000', // ğŸ¨ NOVO: Preto, para um forte contraste com o fundo claro
        bgmSrc: 'sfx/bgm_nivel5.mp3',         // Roxo (Tapete de festa)
        ...EASY_MODE_SETTINGS 
    } 
];
/* ---------------------------- ÃUDIO (ATUALIZADO) ---------------------------- */
// Objetos para SFX (Efeitos Sonoros)
const sfxJump = new Audio('sfx/jump.wav');
const sfxGameOver = new Audio('sfx/gameOver.wav');
const sfxVictory = new Audio('sfx/victory.wav');
const sfxPoint = new Audio('sfx/point.wav');

// Objeto para armazenar as mÃºsicas de fundo por nÃ­vel
let bgMusics = {}; 
let currentBGM = null; // VariÃ¡vel para rastrear a mÃºsica que estÃ¡ tocando

// NOVO: Coleta todos os caminhos de mÃºsica
const bgmSrcList = LEVEL_SETTINGS.map(s => s.bgmSrc); 

// Lista de assets de Ã¡udio para contagem (SFX + MÃºsicas)
const audioAssets = [sfxJump, sfxGameOver, sfxVictory];
bgmSrcList.forEach(src => {
    const audio = new Audio(src);
    audio.loop = true;
    audio.oncanplaythrough = assetLoaded; // Marca como carregado quando puder tocar
    bgMusics[src] = audio; // Armazena no objeto
    audioAssets.push(audio); // Adiciona ao array para contagem
});

audioAssets.forEach(audio => {
    if(!audio.oncanplaythrough) audio.oncanplaythrough = assetLoaded;
});
// O SEU BACKGROUND ANTIGO VAI SER RE-ATRIBUIDO A CADA NÃVEL
const cat = { x: 50, y: canvas.height/2, width: 55, height: 55, velocity:0 }; 
const catImg = new Image();
catImg.src = 'pngwing.com.png'; 


// ğŸ›‘ NOVO: Criamos um array de imagens para carregar todos os fundos
let bgImgs = {}; 
const bgSrcList = LEVEL_SETTINGS.map(s => s.bgSrc);
let bgX = 0; 
let bgSpeed = 0.5; 

// Objeto Image para a tela de vitÃ³ria
const victoryCatImgSource = new Image();
victoryCatImgSource.src = 'greg.png'; 

// ATUALIZAÃ‡ÃƒO DA CONTAGEM DE ASSETS: Gato (1) + VitÃ³ria (1) + 5 Fundos = 7
let totalAssets = 2 + bgSrcList.length + audioAssets.length; 
let assetsLoaded = 0;
let unlockedLevel = 1;

let currentPipeColor = '#1a1a1a';
let currentGroundColor = '#8fbc8f';
let currentPipeCapColor = '#FFFFFF'; // ğŸ¨ NOVO: Cor da tampa, branco por padrÃ£o


/* ---------------------------- TELA DE NÃVEL ---------------------------- */
// ... (cÃ³digo da funÃ§Ã£o renderLevelSelect() sem alteraÃ§Ãµes) ...
function renderLevelSelect() {
Â  Â  levelListContainer.innerHTML = '';
Â  Â  
Â  Â  LEVEL_SETTINGS.forEach((level, index) => {
Â  Â  Â  Â  const levelNumber = index + 1;
Â  Â  Â  Â  const button = document.createElement('button');
Â  Â  Â  Â  button.textContent = `NÃ­vel ${levelNumber}: ${level.name}`;
Â  Â  Â  Â  button.onclick = () => selectLevel(levelNumber);
Â  Â  Â  Â  
Â  Â  Â  Â  if (levelNumber > unlockedLevel) {
Â  Â  Â  Â  Â  Â  button.disabled = true;
Â  Â  Â  Â  Â  Â  button.textContent += ' (Bloqueado)';
Â  Â  Â  Â  }
Â  Â  Â  Â  levelListContainer.appendChild(button);
Â  Â  });
}
// ... (cÃ³digo da funÃ§Ã£o showLevelSelect() sem alteraÃ§Ãµes) ...
function showLevelSelect() {
Â  Â  startScreen.classList.remove('active');
Â  Â  gameOverScreen.classList.remove('active');
Â  Â  levelCompletedScreen.classList.remove('active'); 
Â  Â  levelSelectScreen.classList.add('active');
Â  Â  renderLevelSelect();
Â  Â  
Â  Â  if (animationId) {
Â  Â  Â  Â  cancelAnimationFrame(animationId);
Â  Â  Â  Â  animationId = null;
Â  Â  }
}

function selectLevel(levelNumber) {
Â  Â  currentLevel = levelNumber;
Â  Â  const settings = LEVEL_SETTINGS[levelNumber - 1];
Â  Â  
Â  Â  gravity = settings.gravity;
Â  Â  jumpForce = settings.jump;
Â  Â  pipeSpeed = settings.speed;
Â  Â  minGap = settings.gap;
Â  Â  maxGap = settings.maxGap; 
 // ğŸ›‘ NOVO: Define o fundo, a cor do cano e a cor do chÃ£o
    bgImg = bgImgs[settings.bgSrc];
    currentPipeColor = settings.pipeColor;
    currentGroundColor = settings.groundColor;
    currentPipeCapColor = settings.pipeCapColor; // ğŸ¨ NOVO: Carrega a cor da tampa do nÃ­vel
Â  Â  
    // ğŸ›‘ NOVO: Define o fundo, a cor do cano e a cor do chÃ£o
    bgImg = bgImgs[settings.bgSrc];
    currentPipeColor = settings.pipeColor;
    currentGroundColor = settings.groundColor;

     // ğŸµ NOVO: LÃ“GICA DE MÃšSICA DE FUNDO POR NÃVEL
    stopBGM(); // Para qualquer mÃºsica que possa estar tocando
    currentBGM = bgMusics[settings.bgmSrc]; // Define a nova mÃºsica
Â  Â  
Â  Â  startGame();
}


/* ---------------------------- FunÃ§Ãµes Auxiliares ---------------------------- */
function handleJump() {
Â  Â  if(!gameRunning) return;

// NOVO: Toca o som de pulo
    sfxJump.currentTime = 0; // Reinicia o Ã¡udio para que ele possa ser tocado rapidamente
    sfxJump.play().catch(e => {}); 

Â  Â  cat.velocity = jumpForce; 
}

/* ---------------------------- FunÃ§Ãµes de Controle de Ãudio ---------------------------- */
function stopBGM() {
    if (currentBGM) {
        currentBGM.pause();
        currentBGM.currentTime = 0; // Reinicia para a prÃ³xima vez
    }
}

/* Eventos de controle */
document.addEventListener('keydown', e => { 
Â  Â  if (gameRunning && (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W')) {
Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  handleJump(); 
Â  Â  }
});
canvas.addEventListener('mousedown', () => { 
Â  Â  if(gameRunning) handleJump(); 
});
canvas.addEventListener('touchstart', e => { 
Â  Â  if(gameRunning) { 
Â  Â  Â  Â  e.preventDefault(); 
Â  Â  Â  Â  handleJump(); 
Â  Â  } 
}, {passive:false});


/* ---------------------------- Estado do Jogo ---------------------------- */
// ... (cÃ³digo da funÃ§Ã£o startGame() sem alteraÃ§Ãµes) ...
function startGame() {
Â  Â  levelSelectScreen.classList.remove('active');
Â  Â  gameOverScreen.classList.remove('active');

     // ğŸµ NOVO: Inicia a mÃºsica do nÃ­vel atual
    if (currentBGM) {
        currentBGM.play().catch(e => console.log("MÃºsica do nÃ­vel nÃ£o iniciada."));
    }

Â  Â  resetGameData();
Â  Â  gameRunning = true;
Â  Â  gameOver = false;

    lastTime = 0;

Â  Â  animationId = requestAnimationFrame(draw);

}
// ... (cÃ³digo da funÃ§Ã£o endLevel() sem alteraÃ§Ãµes) ...
function endLevel() {
Â  Â  gameRunning = false;

    // NOVO: Pausa a mÃºsica e toca o SFX de vitÃ³ria
    stopBGM(); // <--- CHAMA A NOVA FUNÃ‡ÃƒO DE PARAR
    sfxVictory.play();

Â  Â  spawnConfetti();
Â  Â  drawConfetti(); 
Â  Â  
Â  Â  if (animationId) {
Â  Â  Â  Â  cancelAnimationFrame(animationId);
Â  Â  Â  Â  animationId = null;
Â  Â  }

Â  Â  const settings = LEVEL_SETTINGS[currentLevel - 1];
Â  Â  
Â  Â  // LÃ³gica para mostrar/esconder a imagem de vitÃ³ria
Â  Â  const isFinalLevel = currentLevel === LEVEL_SETTINGS.length;
Â  Â  victoryCatImg.style.display = isFinalLevel ? 'none' : 'block';

Â  Â  if (!isFinalLevel) { // NÃ­veis 1 a 4
Â  Â  Â  Â  unlockedLevel = Math.max(unlockedLevel, currentLevel + 1);
Â  Â  Â  Â  
Â  Â  Â  Â  // Mensagem de nÃ­vel normal concluÃ­do
Â  Â  Â  Â  victoryText.textContent = settings.message;
Â  Â  Â  Â  victoryText.style.color = '#00ff7f'; 
Â  Â  Â  Â  victoryText.style.fontWeight = 'bold';
Â  Â  Â  Â  victoryText.style.textShadow = '2px 2px 4px #000';
Â  Â  Â  Â  
Â  Â  Â  Â  levelCompletedScreen.classList.add('active');
Â  Â  Â  Â  
Â  Â  } else {
Â  Â  Â  Â  // MENSAGEM FINAL PARA O NÃVEL MÃXIMO (NÃ­vel 5)
Â  Â  Â  Â  victoryText.textContent = FINAL_VICTORY_MESSAGE; 
Â  Â  Â  Â  victoryText.style.color = '#fff'; 
Â  Â  Â  Â  victoryText.style.fontWeight = 'normal';
Â  Â  Â  Â  victoryText.style.textShadow = 'none';

Â  Â  Â  Â  levelCompletedScreen.classList.add('active');
Â  Â  }
}
// ... (cÃ³digo da funÃ§Ã£o endGame() sem alteraÃ§Ãµes) ...
function endGame() {
Â  Â  gameRunning = false;
Â  Â  gameOver = true;

    // NOVO: Pausa a mÃºsica e toca o SFX de derrota
    stopBGM(); // <--- CHAMA A NOVA FUNÃ‡ÃƒO DE PARAR
    sfxGameOver.play(); 

Â  Â  finalScoreText.textContent = `PontuaÃ§Ã£o Final: ${score} (NÃ­vel ${currentLevel})`;
Â  Â  gameOverScreen.classList.add('active');
Â  Â  spawnConfetti();
Â  Â  drawConfetti();
Â  Â  
Â  Â  if (animationId) {
Â  Â  Â  Â  cancelAnimationFrame(animationId);
Â  Â  Â  Â  animationId = null;
Â  Â  }
}

function resetGameData() {
Â  Â  cat.y = canvas.height/2;
Â  Â  cat.velocity = 0;
Â  Â  pipes = [];
Â  Â  score = 0;
Â  Â  
Â  Â  pipeFrame = 0; 
Â  Â  gameSpeed = 0; 
Â  Â  
Â  Â  bgX = 0;
Â  Â  
Â  Â  scoreDisplay.textContent = `Pontos: 0`;
}


/* ---------------------------- GeraÃ§Ã£o de Canos ---------------------------- */
// ... (cÃ³digo da funÃ§Ã£o spawnPipe() sem alteraÃ§Ãµes) ...
function spawnPipe() {
Â  Â  const currentGap = Math.random() * (maxGap - minGap) + minGap; 
Â  Â  
Â  Â  const safeZoneTop = 50; 
Â  Â  const safeZoneBottom = canvas.height - 50 - currentGap; 

Â  Â  const topHeight = Math.random() * (safeZoneBottom - safeZoneTop) + safeZoneTop;

Â  Â  pipes.push({
Â  Â  Â  Â  x: canvas.width,
Â  Â  Â  Â  top: topHeight,
Â  Â  Â  Â  gap: currentGap,
Â  Â  Â  Â  passed:false
Â  Â  });
}


/* ---------------------------- Desenho ---------------------------- */

// FUNÃ‡ÃƒO DE DESENHO DO FUNDO ROLANTE
function drawBackground() {
Â  Â  // ğŸ›‘ NOVO: Usa a imagem bgImg que foi definida no selectLevel
Â  Â  const imgToDraw = bgImg; 
Â  Â  
Â  Â  if (!imgToDraw || !imgToDraw.complete || imgToDraw.naturalWidth === 0) {
Â  Â  Â  Â  // Usa a cor de fundo sÃ³lida se a imagem nÃ£o carregar (agora usa o Fallback)
Â  Â  Â  Â  ctx.fillStyle = '#ADD8E6'; 
Â  Â  Â  Â  ctx.fillRect(0, 0, canvas.width, canvas.height); 
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  let drawWidth = canvas.width;
Â  Â  let drawHeight = drawWidth * (imgToDraw.naturalHeight / imgToDraw.naturalWidth);
Â  Â  
Â  Â  if (drawHeight < canvas.height) {
Â  Â  Â  Â  drawHeight = canvas.height;
Â  Â  Â  Â  drawWidth = drawHeight * (imgToDraw.naturalWidth / imgToDraw.naturalHeight);
Â  Â  }
Â  Â  
Â  Â  const offsetY = 0; 
Â  Â  bgX -= pipeSpeed * (bgSpeed / 2.25); 
Â  Â  
Â  Â  if (bgX <= -drawWidth) {
Â  Â  Â  Â  bgX = 0;
Â  Â  }
Â  Â  
Â  Â  ctx.drawImage(imgToDraw, bgX, offsetY, drawWidth, drawHeight);
Â  Â  ctx.drawImage(imgToDraw, bgX + drawWidth, offsetY, drawWidth, drawHeight);
}

//  

function drawCat() {
Â  Â  ctx.save();
Â  Â  ctx.translate(cat.x + cat.width/2, cat.y + cat.height/2);
Â  Â  ctx.rotate(Math.min(Math.PI/2, Math.max(-Math.PI/4, cat.velocity * 0.05)));
Â  Â  ctx.drawImage(catImg, -cat.width/2, -cat.height/2, cat.width, cat.height);
Â  Â  ctx.restore();
}

// FUNÃ‡ÃƒO DE DESENHO DOS CANOS ATUALIZADA (Usa a cor do nÃ­vel)
function drawPipes() {
Â  Â  // ğŸ›‘ NOVO: Pega a cor do cano do nÃ­vel atual
Â  Â  const PIPE_BODY_COLOR = currentPipeColor; 
Â  Â  const PAW_CAP_COLOR = currentPipeCapColor; Â  
Â  Â  const PAW_CAP_HEIGHT = 20; Â  Â  Â  Â  
Â  Â  
Â  Â  pipes.forEach(pipe => {
Â  Â  Â  Â  const topHeight = pipe.top;
Â  Â  Â  Â  const bottomY = pipe.top + pipe.gap;
Â  Â  Â  Â  const bottomHeight = canvas.height - bottomY - 20;

Â  Â  Â  Â  // --- CANO SUPERIOR ---
Â  Â  Â  Â  ctx.fillStyle = PIPE_BODY_COLOR;
Â  Â  Â  Â  ctx.fillRect(pipe.x, 0, pipeWidth, topHeight); 
Â  Â  Â  Â  ctx.fillStyle = PAW_CAP_COLOR;
Â  Â  Â  Â  ctx.fillRect(pipe.x, topHeight - PAW_CAP_HEIGHT, pipeWidth, PAW_CAP_HEIGHT);
Â  Â  Â  Â  

Â  Â  Â  Â  // --- CANO INFERIOR ---
Â  Â  Â  Â  ctx.fillStyle = PIPE_BODY_COLOR;
Â  Â  Â  Â  ctx.fillRect(pipe.x, bottomY, pipeWidth, bottomHeight);
Â  Â  Â  Â  ctx.fillStyle = PAW_CAP_COLOR;
Â  Â  Â  Â  ctx.fillRect(pipe.x, bottomY, pipeWidth, PAW_CAP_HEIGHT);
Â  Â  });
}

/* ---------------------------- ColisÃµes ---------------------------- */
// ... (cÃ³digo da funÃ§Ã£o checkCollision() sem alteraÃ§Ãµes) ...
function checkCollision() {
Â  Â  // ğŸ›‘ Garante que a colisÃ£o com o chÃ£o e teto respeite o novo tamanho do canvas
Â  Â  if(cat.y + cat.height > canvas.height-20 || cat.y < 0) return true;
Â  Â  
Â  Â  for(const pipe of pipes){
Â  Â  Â  Â  if(cat.x+cat.width > pipe.x && cat.x < pipe.x + pipeWidth){
Â  Â  Â  Â  Â  Â  if(cat.y < pipe.top || cat.y + cat.height > pipe.top+pipe.gap) return true;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  return false;
}

/* ---------------------------- LÃ³gica do Jogo ---------------------------- */
// ... (cÃ³digo da funÃ§Ã£o updateGameLogic() sem alteraÃ§Ãµes) ...
function updateGameLogic() {
Â  Â  cat.velocity += gravity; 
Â  Â  cat.y += cat.velocity;

Â  Â  pipes.forEach(pipe => {
Â  Â  Â  Â  pipe.x -= pipeSpeed; 
Â  Â  Â  Â  
Â  Â  Â  Â  if(pipe.x+pipeWidth < cat.x && !pipe.passed){
Â  Â  Â  Â  Â  Â  score++;
Â  Â  Â  Â  Â  Â  pipe.passed = true;
Â  Â  Â  Â  Â  Â  scoreDisplay.textContent = `Pontos: ${score}`;

          // ğŸµ NOVO: Toca o som de ponto
            sfxPoint.currentTime = 0; // Garante que toque
            sfxPoint.play().catch(e => {}); 
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if (score >= pointsToCompleteLevel) {
Â  Â  Â  Â  Â  Â  Â  Â  endLevel();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  });

Â  Â  if(pipes.length && pipes[0].x+pipeWidth < 0) pipes.shift();
Â  Â  
Â  Â  if(pipeFrame === initialDelay || (pipeFrame > initialDelay && (pipeFrame - initialDelay) % pipeInterval === 0)) {
Â  Â  Â  Â  Â  Â  spawnPipe();
Â  Â  }
Â  Â  
Â  Â  pipeFrame++;
}


/* ---------------------------- Loop Principal (MODIFICADO) ---------------------------- */
// FunÃ§Ã£o draw agora recebe o timestamp do requestAnimationFrame
function draw(currentTime) {
    if (!gameRunning) {
        // Se o jogo nÃ£o estiver rodando, ainda desenhamos o gato na tela de menu/fim
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawBackground();
        // ChÃ£o
        ctx.fillStyle = currentGroundColor;
        ctx.fillRect(0, canvas.height-20, canvas.width, 20);
        drawCat();
        return; // Sai do loop se o jogo nÃ£o estiver ativo
    }
    
    // 1. CÃLCULO DO TEMPO
    if (lastTime === 0) lastTime = currentTime;
    let deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // Evita o "espirro" do deltaTime apÃ³s pausar (ex: trocar de aba)
    // Limita o delta em 250ms para evitar que o jogo "salte" frames apÃ³s uma longa pausa.
    if (deltaTime > 250) deltaTime = 250; 
    
    accumulatedTime += deltaTime;

    // 2. ATUALIZAÃ‡ÃƒO DA LÃ“GICA EM TEMPO FIXO
    // Enquanto tivermos tempo acumulado suficiente, rodamos a lÃ³gica do jogo
    let updateCount = 0;
    while (accumulatedTime >= TIME_STEP) {
        // Chama a funÃ§Ã£o de atualizaÃ§Ã£o de lÃ³gica.
        // JÃ¡ que a lÃ³gica Ã© chamada em tempo fixo (TIME_STEP), 
        // podemos remover a variÃ¡vel 'gameSpeed' e 'GAME_TICK_RATE' da lÃ³gica de jogo.
        updateGameLogic(); 
        
        // Verifica colisÃµes APÃ“S a lÃ³gica
        if(checkCollision()) {
            endGame();
            accumulatedTime = 0; // Limpa para sair do while
            break; // Sai do loop interno
        }

        accumulatedTime -= TIME_STEP;
        updateCount++;
        
        // ProteÃ§Ã£o para evitar loop infinito (raro, mas seguro)
        if (updateCount > 10) { 
            accumulatedTime = 0; 
            break; 
        }
    }

    // 3. DESENHO
    // O desenho continua usando o requestAnimationFrame, mas a lÃ³gica jÃ¡ foi estabilizada.
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    drawBackground();

    // ChÃ£o
    ctx.fillStyle = currentGroundColor;
    ctx.fillRect(0, canvas.height-20, canvas.width, 20);

    drawPipes();
    drawCat();

    // 4. PRÃ“XIMO QUADRO
    animationId = requestAnimationFrame(draw);
}

/* ---------------------------- Confetti (Mantido) ---------------------------- */
let confetti = [];
let confettiAnimationId = null;

function spawnConfetti(){
Â  Â  confetti = [];
Â  Â  for(let i=0;i<100;i++){
Â  Â  Â  Â  confetti.push({
Â  Â  Â  Â  Â  Â  x: Math.random()*canvas.width,
Â  Â  Â  Â  Â  Â  y: 0,
Â  Â  Â  Â  Â  Â  r: Math.random()*4+2,
Â  Â  Â  Â  Â  Â  d: Math.random()*100,
Â  Â  Â  Â  Â  Â  color: ['#ff99aa','#ffcc00','#5c99ff'][Math.floor(Math.random()*3)]
Â  Â  Â  Â  });
Â  Â  }
Â  Â  if (!confettiAnimationId) drawConfetti();
}

function drawConfetti(){
Â  Â  confCtx.clearRect(0,0,canvas.width,confCanvas.height); 
Â  Â  confetti.forEach(c=>{
Â  Â  Â  Â  confCtx.fillStyle = c.color;
Â  Â  Â  Â  confCtx.beginPath();
Â  Â  Â  Â  confCtx.arc(c.x,c.y,c.r,0,2*Math.PI);
Â  Â  Â  Â  confCtx.fill();
Â  Â  Â  Â  c.y += 2 + c.d/50;
Â  Â  Â  Â  if(c.y>confCanvas.height) c.y=0; 
Â  Â  });
Â  Â  
Â  Â  if(gameOver || levelCompletedScreen.classList.contains('active')) {
Â  Â  Â  Â  confettiAnimationId = requestAnimationFrame(drawConfetti); 
Â  Â  } else {
Â  Â  Â  Â  cancelAnimationFrame(confettiAnimationId);
Â  Â  Â  Â  confettiAnimationId = null;
Â  Â  }
}


/* ---------------------------- Assets & InicializaÃ§Ã£o ---------------------------- */
let gameInitialized = false; 

function initializeGame() {
Â  Â  if (gameInitialized) return;
Â  Â  gameInitialized = true;
    
    // ğŸ›‘ NOVO: Define o fundo inicial na inicializaÃ§Ã£o
    bgImg = bgImgs[LEVEL_SETTINGS[0].bgSrc];
    currentPipeColor = LEVEL_SETTINGS[0].pipeColor;
    currentGroundColor = LEVEL_SETTINGS[0].groundColor;
Â  Â  
Â  Â  gameOverScreen.classList.remove('active'); 
Â  Â  levelSelectScreen.classList.remove('active');
Â  Â  levelCompletedScreen.classList.remove('active'); 
Â  Â  
Â  Â  draw(); 
Â  Â  unlockedLevel = 1;
Â  Â  
Â  Â  // Mostra a tela inicial
Â  Â  if (!levelSelectScreen.classList.contains('active')) {
Â  Â  Â  Â  Â startScreen.classList.add('active');
Â  Â  }
}

// ğŸ›‘ NOVO: FunÃ§Ã£o de carregamento que lida com mÃºltiplos fundos
function loadBackgroundAssets() {
    bgSrcList.forEach(src => {
        const img = new Image();
        img.onload = assetLoaded;
        img.src = src;
        bgImgs[src] = img;
    });
}

function assetLoaded(){
Â  Â  assetsLoaded++;
Â  Â  // O jogo sÃ³ comeÃ§a se todos os assets carregaram E ainda nÃ£o foi inicializado.
Â  Â  if(assetsLoaded === totalAssets && !gameInitialized){
Â  Â  Â  Â  initializeGame();
Â  Â  }
}


catImg.onload = assetLoaded;
victoryCatImgSource.onload = assetLoaded; 
// ğŸ›‘ NOVO: Chama a funÃ§Ã£o para carregar todos os fundos
loadBackgroundAssets(); 

// LÃ“GICA DE REDIMENSIONAMENTO OTIMIZADA PARA CELULAR
function resizeCanvas() {
Â  Â  const container = document.getElementById('game-container');
Â  Â  const newWidth = container.clientWidth;
Â  Â  const newHeight = container.clientHeight;

Â  Â  canvas.width = newWidth;
Â  Â  canvas.height = newHeight;
Â  Â  confCanvas.width = newWidth;
Â  Â  confCanvas.height = newHeight;

Â  Â  if (gameRunning) {
Â  Â  Â  Â  // Se estiver jogando, forÃ§amos o fim para evitar bugs de canos
Â  Â  Â  Â  endGame();
Â  Â  } else {
Â  Â  Â  Â  // Se estiver nas telas de menu, apenas centralizamos o gatinho
Â  Â  Â  Â  cat.y = canvas.height / 2 - cat.height / 2;
Â  Â  }
}

window.addEventListener('resize', resizeCanvas);

document.addEventListener('DOMContentLoaded', () => {
Â  Â  resizeCanvas();
Â  Â  
Â  Â  // ğŸ›‘ GARANTIA DE INICIALIZAÃ‡ÃƒO (Mobile Fix): Se apÃ³s 2 segundos (2000ms) o jogo nÃ£o tiver iniciado (por falha no asset), ele inicia mesmo assim.
Â  Â  setTimeout(() => {
Â  Â  Â  Â  if (!gameInitialized) {
Â  Â  Â  Â  Â  Â  console.warn("ForÃ§ando inicializaÃ§Ã£o do jogo devido a falha no carregamento de assets.");
Â  Â  Â  Â  Â  Â  // Define o total de assets como os assets que jÃ¡ carregaram para iniciar o jogo imediatamente.
Â  Â  Â  Â  Â  Â  totalAssets = assetsLoaded; 
Â  Â  Â  Â  Â  Â  initializeGame();
Â  Â  Â  Â  }
Â  Â  }, 2000); 
});

Â  if ('serviceWorker' in navigator) {
Â  Â  window.addEventListener('load', () => {
Â  Â  Â  navigator.serviceWorker.register('sw.js').then(registration => {
Â  Â  Â  Â  console.log('Service Worker registrado com sucesso:', registration);
Â  Â  Â  }).catch(error => {
Â  Â  Â  Â  console.log('Falha ao registrar o Service Worker:', error);
Â  Â  Â  });
Â  Â  });
Â  }

</script>
</body>
</html>
